
global f32 global_debug_sphere_model_data[] = {
    0.000000f,-1.000000f,0.000000f,0.425323f,-0.850654f,0.309011f,-0.162456f,-0.850654f,
    0.499995f,0.723607f,-0.447220f,0.525725f,0.425323f,-0.850654f,0.309011f,0.850648f,
    -0.525736f,0.000000f,0.000000f,-1.000000f,0.000000f,-0.162456f,-0.850654f,0.499995f,
    -0.525730f,-0.850652f,0.000000f,0.000000f,-1.000000f,0.000000f,-0.525730f,-0.850652f,
    0.000000f,-0.162456f,-0.850654f,-0.499995f,0.000000f,-1.000000f,0.000000f,-0.162456f,
    -0.850654f,-0.499995f,0.425323f,-0.850654f,-0.309011f,0.723607f,-0.447220f,0.525725f,
    0.850648f,-0.525736f,0.000000f,0.951058f,0.000000f,0.309013f,-0.276388f,-0.447220f,
    0.850649f,0.262869f,-0.525738f,0.809012f,0.000000f,0.000000f,1.000000f,-0.894426f,
    -0.447216f,0.000000f,-0.688189f,-0.525736f,0.499997f,-0.951058f,0.000000f,0.309013f,
    -0.276388f,-0.447220f,-0.850649f,-0.688189f,-0.525736f,-0.499997f,-0.587786f,0.000000f,
    -0.809017f,0.723607f,-0.447220f,-0.525725f,0.262869f,-0.525738f,-0.809012f,0.587786f,
    0.000000f,-0.809017f,0.723607f,-0.447220f,0.525725f,0.951058f,0.000000f,0.309013f,
    0.587786f,0.000000f,0.809017f,-0.276388f,-0.447220f,0.850649f,0.000000f,0.000000f,
    1.000000f,-0.587786f,0.000000f,0.809017f,-0.894426f,-0.447216f,0.000000f,-0.951058f,
    0.000000f,0.309013f,-0.951058f,0.000000f,-0.309013f,-0.276388f,-0.447220f,-0.850649f,
    -0.587786f,0.000000f,-0.809017f,0.000000f,0.000000f,-1.000000f,0.723607f,-0.447220f,
    -0.525725f,0.587786f,0.000000f,-0.809017f,0.951058f,0.000000f,-0.309013f,0.276388f,
    0.447220f,0.850649f,0.688189f,0.525736f,0.499997f,0.162456f,0.850654f,0.499995f,
    -0.723607f,0.447220f,0.525725f,-0.262869f,0.525738f,0.809012f,-0.425323f,0.850654f,
    0.309011f,-0.723607f,0.447220f,-0.525725f,-0.850648f,0.525736f,0.000000f,-0.425323f,
    0.850654f,-0.309011f,0.276388f,0.447220f,-0.850649f,-0.262869f,0.525738f,-0.809012f,
    0.162456f,0.850654f,-0.499995f,0.894426f,0.447216f,0.000000f,0.688189f,0.525736f,
    -0.499997f,0.525730f,0.850652f,0.000000f,0.525730f,0.850652f,0.000000f,0.162456f,
    0.850654f,-0.499995f,0.000000f,1.000000f,0.000000f,0.525730f,0.850652f,0.000000f,
    0.688189f,0.525736f,-0.499997f,0.162456f,0.850654f,-0.499995f,0.688189f,0.525736f,
    -0.499997f,0.276388f,0.447220f,-0.850649f,0.162456f,0.850654f,-0.499995f,0.162456f,
    0.850654f,-0.499995f,-0.425323f,0.850654f,-0.309011f,0.000000f,1.000000f,0.000000f,
    0.162456f,0.850654f,-0.499995f,-0.262869f,0.525738f,-0.809012f,-0.425323f,0.850654f,
    -0.309011f,-0.262869f,0.525738f,-0.809012f,-0.723607f,0.447220f,-0.525725f,-0.425323f,
    0.850654f,-0.309011f,-0.425323f,0.850654f,-0.309011f,-0.425323f,0.850654f,0.309011f,
    0.000000f,1.000000f,0.000000f,-0.425323f,0.850654f,-0.309011f,-0.850648f,0.525736f,
    0.000000f,-0.425323f,0.850654f,0.309011f,-0.850648f,0.525736f,0.000000f,-0.723607f,
    0.447220f,0.525725f,-0.425323f,0.850654f,0.309011f,-0.425323f,0.850654f,0.309011f,
    0.162456f,0.850654f,0.499995f,0.000000f,1.000000f,0.000000f,-0.425323f,0.850654f,
    0.309011f,-0.262869f,0.525738f,0.809012f,0.162456f,0.850654f,0.499995f,-0.262869f,
    0.525738f,0.809012f,0.276388f,0.447220f,0.850649f,0.162456f,0.850654f,0.499995f,
    0.162456f,0.850654f,0.499995f,0.525730f,0.850652f,0.000000f,0.000000f,1.000000f,
    0.000000f,0.162456f,0.850654f,0.499995f,0.688189f,0.525736f,0.499997f,0.525730f,
    0.850652f,0.000000f,0.688189f,0.525736f,0.499997f,0.894426f,0.447216f,0.000000f,
    0.525730f,0.850652f,0.000000f,0.951058f,0.000000f,-0.309013f,0.688189f,0.525736f,
    -0.499997f,0.894426f,0.447216f,0.000000f,0.951058f,0.000000f,-0.309013f,0.587786f,
    0.000000f,-0.809017f,0.688189f,0.525736f,-0.499997f,0.587786f,0.000000f,-0.809017f,
    0.276388f,0.447220f,-0.850649f,0.688189f,0.525736f,-0.499997f,0.000000f,0.000000f,
    -1.000000f,-0.262869f,0.525738f,-0.809012f,0.276388f,0.447220f,-0.850649f,0.000000f,
    0.000000f,-1.000000f,-0.587786f,0.000000f,-0.809017f,-0.262869f,0.525738f,-0.809012f,
    -0.587786f,0.000000f,-0.809017f,-0.723607f,0.447220f,-0.525725f,-0.262869f,0.525738f,
    -0.809012f,-0.951058f,0.000000f,-0.309013f,-0.850648f,0.525736f,0.000000f,-0.723607f,
    0.447220f,-0.525725f,-0.951058f,0.000000f,-0.309013f,-0.951058f,0.000000f,0.309013f,
    -0.850648f,0.525736f,0.000000f,-0.951058f,0.000000f,0.309013f,-0.723607f,0.447220f,
    0.525725f,-0.850648f,0.525736f,0.000000f,-0.587786f,0.000000f,0.809017f,-0.262869f,
    0.525738f,0.809012f,-0.723607f,0.447220f,0.525725f,-0.587786f,0.000000f,0.809017f,
    0.000000f,0.000000f,1.000000f,-0.262869f,0.525738f,0.809012f,0.000000f,0.000000f,
    1.000000f,0.276388f,0.447220f,0.850649f,-0.262869f,0.525738f,0.809012f,0.587786f,
    0.000000f,0.809017f,0.688189f,0.525736f,0.499997f,0.276388f,0.447220f,0.850649f,
    0.587786f,0.000000f,0.809017f,0.951058f,0.000000f,0.309013f,0.688189f,0.525736f,
    0.499997f,0.951058f,0.000000f,0.309013f,0.894426f,0.447216f,0.000000f,0.688189f,
    0.525736f,0.499997f,0.587786f,0.000000f,-0.809017f,0.000000f,0.000000f,-1.000000f,
    0.276388f,0.447220f,-0.850649f,0.587786f,0.000000f,-0.809017f,0.262869f,-0.525738f,
    -0.809012f,0.000000f,0.000000f,-1.000000f,0.262869f,-0.525738f,-0.809012f,-0.276388f,
    -0.447220f,-0.850649f,0.000000f,0.000000f,-1.000000f,-0.587786f,0.000000f,-0.809017f,
    -0.951058f,0.000000f,-0.309013f,-0.723607f,0.447220f,-0.525725f,-0.587786f,0.000000f,
    -0.809017f,-0.688189f,-0.525736f,-0.499997f,-0.951058f,0.000000f,-0.309013f,-0.688189f,
    -0.525736f,-0.499997f,-0.894426f,-0.447216f,0.000000f,-0.951058f,0.000000f,-0.309013f,
    -0.951058f,0.000000f,0.309013f,-0.587786f,0.000000f,0.809017f,-0.723607f,0.447220f,
    0.525725f,-0.951058f,0.000000f,0.309013f,-0.688189f,-0.525736f,0.499997f,-0.587786f,
    0.000000f,0.809017f,-0.688189f,-0.525736f,0.499997f,-0.276388f,-0.447220f,0.850649f,
    -0.587786f,0.000000f,0.809017f,0.000000f,0.000000f,1.000000f,0.587786f,0.000000f,
    0.809017f,0.276388f,0.447220f,0.850649f,0.000000f,0.000000f,1.000000f,0.262869f,
    -0.525738f,0.809012f,0.587786f,0.000000f,0.809017f,0.262869f,-0.525738f,0.809012f,
    0.723607f,-0.447220f,0.525725f,0.587786f,0.000000f,0.809017f,0.951058f,0.000000f,
    0.309013f,0.951058f,0.000000f,-0.309013f,0.894426f,0.447216f,0.000000f,0.951058f,
    0.000000f,0.309013f,0.850648f,-0.525736f,0.000000f,0.951058f,0.000000f,-0.309013f,
    0.850648f,-0.525736f,0.000000f,0.723607f,-0.447220f,-0.525725f,0.951058f,0.000000f,
    -0.309013f,0.425323f,-0.850654f,-0.309011f,0.262869f,-0.525738f,-0.809012f,0.723607f,
    -0.447220f,-0.525725f,0.425323f,-0.850654f,-0.309011f,-0.162456f,-0.850654f,-0.499995f,
    0.262869f,-0.525738f,-0.809012f,-0.162456f,-0.850654f,-0.499995f,-0.276388f,-0.447220f,
    -0.850649f,0.262869f,-0.525738f,-0.809012f,-0.162456f,-0.850654f,-0.499995f,-0.688189f,
    -0.525736f,-0.499997f,-0.276388f,-0.447220f,-0.850649f,-0.162456f,-0.850654f,-0.499995f,
    -0.525730f,-0.850652f,0.000000f,-0.688189f,-0.525736f,-0.499997f,-0.525730f,-0.850652f,
    0.000000f,-0.894426f,-0.447216f,0.000000f,-0.688189f,-0.525736f,-0.499997f,-0.525730f,
    -0.850652f,0.000000f,-0.688189f,-0.525736f,0.499997f,-0.894426f,-0.447216f,0.000000f,
    -0.525730f,-0.850652f,0.000000f,-0.162456f,-0.850654f,0.499995f,-0.688189f,-0.525736f,
    0.499997f,-0.162456f,-0.850654f,0.499995f,-0.276388f,-0.447220f,0.850649f,-0.688189f,
    -0.525736f,0.499997f,0.850648f,-0.525736f,0.000000f,0.425323f,-0.850654f,-0.309011f,
    0.723607f,-0.447220f,-0.525725f,0.850648f,-0.525736f,0.000000f,0.425323f,-0.850654f,
    0.309011f,0.425323f,-0.850654f,-0.309011f,0.425323f,-0.850654f,0.309011f,0.000000f,
    -1.000000f,0.000000f,0.425323f,-0.850654f,-0.309011f,-0.162456f,-0.850654f,0.499995f,
    0.262869f,-0.525738f,0.809012f,-0.276388f,-0.447220f,0.850649f,-0.162456f,-0.850654f,
    0.499995f,0.425323f,-0.850654f,0.309011f,0.262869f,-0.525738f,0.809012f,0.425323f,
    -0.850654f,0.309011f,0.723607f,-0.447220f,0.525725f,0.262869f,-0.525738f,0.809012f,
};

static GLuint
InitOpenGLShaderFromData(OpenGLShaderInput *inputs, int input_count,
                         OpenGLShaderOutput *outputs, int output_count,
                         char *vertex, char *fragment)
{
    GLuint program = 0;
    GLuint vertex_shader = 0;
    GLuint fragment_shader = 0;
    
    int info_log_length = 0;
    GLint result = GL_FALSE;
    GLint code_length = 0;
    
    // NOTE(rjf): Compile and attach vertex shader
    {
        vertex_shader = glCreateShader(GL_VERTEX_SHADER);
        code_length = (GLint)CalculateCStringLength(vertex);
        glShaderSource(vertex_shader, 1, &vertex, &code_length);
        glCompileShader(vertex_shader);
        
        // NOTE(rjf): Get vertex shader errors
        {
            glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &result);
            glGetShaderiv(vertex_shader, GL_INFO_LOG_LENGTH, &info_log_length);
            if(info_log_length > 1)
            {
                char vertex_shader_error[1024] = {0};
                info_log_length = ClampI32(info_log_length, 0, sizeof(vertex_shader_error)-1);
                glGetShaderInfoLog(vertex_shader, info_log_length, 0, vertex_shader_error);
                Log("%s", vertex_shader_error);
            }
            else
            {
                Log("Vertex shader compiled successfully.");
            }
        }
    }
    
    // NOTE(rjf): Compile and attach fragment shader
    {
        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
        code_length = (GLint)CalculateCStringLength(fragment);
        glShaderSource(fragment_shader, 1, &fragment, &code_length);
        glCompileShader(fragment_shader);
        
        // NOTE(rjf): Get fragment shader errors
        {
            glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &result);
            glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &info_log_length);
            if(info_log_length > 1)
            {
                char fragment_shader_error[1024] = {0};
                info_log_length = ClampI32(info_log_length, 0, sizeof(fragment_shader_error)-1);
                glGetShaderInfoLog(fragment_shader, info_log_length, 0, fragment_shader_error);
                Log("%s", fragment_shader_error);
            }
            else
            {
                Log("Fragment shader compiled successfully.");
            }
        }
    }
    
    program = glCreateProgram();
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    
    // NOTE(rjf): Specify shader inputs
    {
        for(int i = 0; i < input_count; ++i)
        {
            glBindAttribLocation(program, inputs[i].index, inputs[i].name);
        }
    }
    
    // NOTE(rjf): Specify shader outputs
    {
        for(int i = 0; i < output_count; ++i)
        {
            glBindFragDataLocation(program, outputs[i].index, outputs[i].name);
        }
    }
    
    // NOTE(rjf): Link shaders
    {
        glLinkProgram(program);
        glDeleteShader(vertex_shader);
        glDeleteShader(fragment_shader);
    }
    
    glValidateProgram(program);
    
    return program;
}

internal RendererOpenGLFBO
RendererOpenGLFBOInit(u32 width, u32 height, i32 flags)
{
    RendererOpenGLFBO fbo = {0};
    fbo.flags = flags;
    fbo.width = width + 1;
    fbo.height = height + 1;
    glGenFramebuffers(1, &fbo.fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, fbo.fbo);
    {
        GLenum colors[4] = {0};
        u32 color_count = 0;
        
        if(flags & RENDERER_OPENGL_FBO_COLOR_OUT_0)
        {
            glGenTextures(1, fbo.color_textures+0);
            glBindTexture(GL_TEXTURE_2D, fbo.color_textures[0]);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, fbo.color_textures[0], 0);
            colors[color_count++] = GL_COLOR_ATTACHMENT0;
        }
        
        if(flags & RENDERER_OPENGL_FBO_COLOR_OUT_1)
        {
            glGenTextures(1, fbo.color_textures+1);
            glBindTexture(GL_TEXTURE_2D, fbo.color_textures[1]);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, fbo.color_textures[1], 0);
            colors[color_count++] = GL_COLOR_ATTACHMENT1;
        }
        
        if(flags & RENDERER_OPENGL_FBO_COLOR_OUT_2)
        {
            glGenTextures(1, fbo.color_textures+2);
            glBindTexture(GL_TEXTURE_2D, fbo.color_textures[2]);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, fbo.color_textures[2], 0);
            colors[color_count++] = GL_COLOR_ATTACHMENT2;
        }
        
        if(flags & RENDERER_OPENGL_FBO_COLOR_OUT_3)
        {
            glGenTextures(1, fbo.color_textures+3);
            glBindTexture(GL_TEXTURE_2D, fbo.color_textures[3]);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT3, GL_TEXTURE_2D, fbo.color_textures[3], 0);
            colors[color_count++] = GL_COLOR_ATTACHMENT3;
        }
        
        if(flags & RENDERER_OPENGL_FBO_DEPTH_OUT)
        {
            glGenTextures(1, &fbo.depth_texture);
            glBindTexture(GL_TEXTURE_2D, fbo.depth_texture);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, fbo.depth_texture, 0);
        }
        
        glDrawBuffers(color_count, colors);
        
    }
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    return fbo;
};

internal void
RendererOpenGLFBOCleanUp(RendererOpenGLFBO *fbo)
{
    glDeleteFramebuffers(1, &fbo->fbo);
    for(u32 i = 0; i < ArrayCount(fbo->color_textures); ++i)
    {
        if(fbo->color_textures[i])
        {
            glDeleteTextures(1, &fbo->color_textures[i]);
        }
    }
    if(fbo->depth_texture)
    {
        glDeleteTextures(1, &fbo->depth_texture);
    }
    fbo->fbo = 0;
}

internal void
RendererOpenGLFBOForceSize(RendererOpenGLFBO *fbo, u32 w, u32 h, i32 flags)
{
    u32 adjusted_width = w + 1;
    u32 adjusted_height = h + 1;
    if(fbo->w != adjusted_width || fbo->h != adjusted_height)
    {
        RendererOpenGLFBOCleanUp(fbo);
        *fbo = RendererOpenGLFBOInit(w, h, flags);
    }
}

internal void
RendererOpenGLFBOBind(Renderer *renderer, RendererOpenGLFBO *fbo)
{
    if(fbo)
    {
        glViewport(0, 0, (GLsizei)fbo->w, (GLsizei)fbo->h);
        glBindFramebuffer(GL_FRAMEBUFFER, fbo->fbo);
        glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    }
    else
    {
        glViewport(0, 0, (GLsizei)renderer->render_w, (GLsizei)renderer->render_h);
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    }
    renderer->active_fbo = fbo;
}

internal void
RendererOpenGLFBOClear(Renderer *renderer, RendererOpenGLFBO *fbo)
{
    RendererOpenGLFBO *last_fbo = renderer->active_fbo;
    RendererOpenGLFBOBind(renderer, fbo);
    glClearColor(0.f, 0.f, 0.f, 0.f);
    if(fbo->depth_texture)
    {
        glDepthMask(GL_TRUE);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    else
    {
        glClear(GL_COLOR_BUFFER_BIT);
    }
    RendererOpenGLFBOBind(renderer, last_fbo);
}

internal void
RendererOpenGLBlurredFBORender(Renderer *renderer, GLuint texture, f32 width, f32 height,
                               b32 vertical, f32 standard_deviation, i32 radius, v4 clip)
{
    GLuint shader = renderer->shaders[OPENGL_SHADER_gaussian_blur];
    glBindVertexArray(renderer->all_purpose_vao);
    glUseProgram(shader);
    {
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
                        GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
                        GL_CLAMP_TO_EDGE);
        
        glUniform4f(glGetUniformLocation(shader, "destination"),
                    0, 0, width, height);
        
        glUniform1i(glGetUniformLocation(shader, "tex"), 0);
        glUniform2f(glGetUniformLocation(shader, "tex_resolution"), width - 1.f, height - 1.f);
        glUniform1i(glGetUniformLocation(shader, "radius"), radius);
        glUniform1i(glGetUniformLocation(shader, "vertical"), !!vertical);
        glUniform4f(glGetUniformLocation(shader, "clip"),
                    clip.x, renderer->render_h - clip.y - clip.height, clip.z, clip.w);
        
        local_persist const i32 kernel_size = 128;
        i32 kernel_midpoint = kernel_size / 2;
        i32 kernel_lower_bound = kernel_midpoint - radius;
        i32 kernel_upper_bound = kernel_midpoint + radius;
        
        f32 vec4_buffer_because_glsl_sucks[4] = {0};
        i32 vec4_counter_because_glsl_sucks = 0;
        
        char kernel_uniform_str_1_digit_index_because_glsl_sucks[32] = "kernel[x]";
        char kernel_uniform_str_2_digit_index_because_glsl_sucks[32] = "kernel[xx]";
        
        for(i32 i = kernel_lower_bound;
            i >= 0 &&
            i <= kernel_upper_bound &&
            i <= kernel_size;
            ++i)
        {
            
            f32 x = (f32)(kernel_midpoint - i);
            
            vec4_buffer_because_glsl_sucks[vec4_counter_because_glsl_sucks++] =
                (ONE_OVER_SQUARE_ROOT_OF_TWO_PIf / standard_deviation) *
                PowF(EULERS_NUMBERf, -(x * x) / (2 * standard_deviation * standard_deviation));
            
            char *kernel_uniform_str = 0;
            i32 kernel_vec4_index_because_glsl_sucks = i / 4;
            
            if(kernel_vec4_index_because_glsl_sucks < 10)
            {
                kernel_uniform_str = kernel_uniform_str_1_digit_index_because_glsl_sucks;
                kernel_uniform_str[7] = '0' + kernel_vec4_index_because_glsl_sucks;
            }
            else if(kernel_vec4_index_because_glsl_sucks < 100)
            {
                kernel_uniform_str = kernel_uniform_str_2_digit_index_because_glsl_sucks;
                snprintf(kernel_uniform_str + 7, 4, "%i]", kernel_vec4_index_because_glsl_sucks);
            }
            
            if(kernel_uniform_str)
            {
                if(vec4_counter_because_glsl_sucks >= 4)
                {
                    vec4_counter_because_glsl_sucks = 0;
                    glUniform4f(glGetUniformLocation(shader, kernel_uniform_str),
                                vec4_buffer_because_glsl_sucks[0],
                                vec4_buffer_because_glsl_sucks[1],
                                vec4_buffer_because_glsl_sucks[2],
                                vec4_buffer_because_glsl_sucks[3]);
                }
            }
        }
        
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    }
    glBindVertexArray(0);
}

internal void
LoadAllOpenGLProcedures(void)
{
    
#define GLProc(type, name) gl##name = (PFNGL##type##PROC)platform->LoadOpenGLProcedure("gl" #name);
#include "opengl_procedure_list.h"
    
}

internal void
_SetOpenGLInstancedFloatAttributeData(int index, int stride, int size, int offset)
{
    glEnableVertexAttribArray(index);
    glVertexAttribPointer(index, size, GL_FLOAT, GL_FALSE, stride,
                          (void *)(sizeof(f32)*offset));
    glVertexAttribDivisor(index, 1);
}

internal void
RendererInit(Renderer *renderer)
{
    HardAssert(platform->LoadOpenGLProcedure != 0);
    LoadAllOpenGLProcedures();
    
    glDisable(GL_CULL_FACE);
    glEnable(GL_BLEND);
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_DEPTH_TEST);
    
    GLfloat filled_quad_vertices[8] = {0};
    
    glGenVertexArrays(1, &renderer->all_purpose_vao);
    
    // NOTE(rjf): Initialize primitive vertices
    {
        filled_quad_vertices[0] = 0;
        filled_quad_vertices[1] = 0;
        filled_quad_vertices[2] = 0;
        filled_quad_vertices[3] = 1;
        filled_quad_vertices[4] = 1;
        filled_quad_vertices[5] = 0;
        filled_quad_vertices[6] = 1;
        filled_quad_vertices[7] = 1;
    }
    
    // NOTE(rjf): Initialize line data
    {
        glGenVertexArrays(1, &renderer->line_vao);
        glBindVertexArray(renderer->line_vao);
        {
            glGenBuffers(1, &renderer->line_instance_buffer);
            glBindBuffer(GL_ARRAY_BUFFER, renderer->line_instance_buffer);
            glBufferData(GL_ARRAY_BUFFER, sizeof(renderer->line_instance_data), 0, GL_DYNAMIC_DRAW);
            _SetOpenGLInstancedFloatAttributeData(0, RENDERER_OPENGL_BYTES_PER_LINE, 3, 0);
            _SetOpenGLInstancedFloatAttributeData(1, RENDERER_OPENGL_BYTES_PER_LINE, 3, 3);
            _SetOpenGLInstancedFloatAttributeData(2, RENDERER_OPENGL_BYTES_PER_LINE, 4, 6);
        }
        glBindVertexArray(0);
    }
    
    // NOTE(rjf): Initialize filled rectangle data
    {
        glGenVertexArrays(1, &renderer->filled_rect_vao);
        glBindVertexArray(renderer->filled_rect_vao);
        {
            glGenBuffers(1, &renderer->filled_rect_instance_buffer);
            glBindBuffer(GL_ARRAY_BUFFER, renderer->filled_rect_instance_buffer);
            glBufferData(GL_ARRAY_BUFFER, sizeof(renderer->filled_rect_instance_data), 0, GL_DYNAMIC_DRAW);
            _SetOpenGLInstancedFloatAttributeData(0, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 3, 0);
            _SetOpenGLInstancedFloatAttributeData(1, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 3, 3);
            _SetOpenGLInstancedFloatAttributeData(2, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 3, 6);
            _SetOpenGLInstancedFloatAttributeData(3, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 3, 9);
            _SetOpenGLInstancedFloatAttributeData(4, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 4, 12);
            _SetOpenGLInstancedFloatAttributeData(5, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 4, 16);
            _SetOpenGLInstancedFloatAttributeData(6, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 4, 20);
            _SetOpenGLInstancedFloatAttributeData(7, RENDERER_OPENGL_BYTES_PER_FILLED_RECT, 4, 24);
        }
        glBindVertexArray(0);
    }
    
    // NOTE(rjf): Initialize texture data
    {
        glGenVertexArrays(1, &renderer->texture_vao);
        glBindVertexArray(renderer->texture_vao);
        {
            glGenBuffers(1, &renderer->texture_instance_buffer);
            glBindBuffer(GL_ARRAY_BUFFER, renderer->texture_instance_buffer);
            glBufferData(GL_ARRAY_BUFFER, sizeof(renderer->texture_instance_data), 0, GL_DYNAMIC_DRAW);
            _SetOpenGLInstancedFloatAttributeData(0, RENDERER_OPENGL_BYTES_PER_TEXTURE, 4, 0);
            _SetOpenGLInstancedFloatAttributeData(1, RENDERER_OPENGL_BYTES_PER_TEXTURE, 3, 4);
            _SetOpenGLInstancedFloatAttributeData(2, RENDERER_OPENGL_BYTES_PER_TEXTURE, 3, 7);
            _SetOpenGLInstancedFloatAttributeData(3, RENDERER_OPENGL_BYTES_PER_TEXTURE, 3, 10);
            _SetOpenGLInstancedFloatAttributeData(4, RENDERER_OPENGL_BYTES_PER_TEXTURE, 3, 13);
            _SetOpenGLInstancedFloatAttributeData(5, RENDERER_OPENGL_BYTES_PER_TEXTURE, 4, 16);
        }
        glBindVertexArray(0);
    }
    
    // NOTE(rjf): Initialize text data
    {
        glGenVertexArrays(1, &renderer->text_vao);
        glBindVertexArray(renderer->text_vao);
        {
            glGenBuffers(1, &renderer->text_instance_buffer);
            glBindBuffer(GL_ARRAY_BUFFER, renderer->text_instance_buffer);
            glBufferData(GL_ARRAY_BUFFER, sizeof(renderer->text_instance_data), 0, GL_DYNAMIC_DRAW);
            _SetOpenGLInstancedFloatAttributeData(0, RENDERER_OPENGL_BYTES_PER_TEXT, 4, 0);
            _SetOpenGLInstancedFloatAttributeData(1, RENDERER_OPENGL_BYTES_PER_TEXT, 3, 4);
            _SetOpenGLInstancedFloatAttributeData(2, RENDERER_OPENGL_BYTES_PER_TEXT, 3, 7);
            _SetOpenGLInstancedFloatAttributeData(3, RENDERER_OPENGL_BYTES_PER_TEXT, 3, 10);
            _SetOpenGLInstancedFloatAttributeData(4, RENDERER_OPENGL_BYTES_PER_TEXT, 3, 13);
            _SetOpenGLInstancedFloatAttributeData(5, RENDERER_OPENGL_BYTES_PER_TEXT, 4, 16);
            _SetOpenGLInstancedFloatAttributeData(6, RENDERER_OPENGL_BYTES_PER_TEXT, 1, 20);
            _SetOpenGLInstancedFloatAttributeData(7, RENDERER_OPENGL_BYTES_PER_TEXT, 1, 21);
        }
        glBindVertexArray(0);
    }
    
    // NOTE(rjf): Initialize debug sphere data
    {
        glGenVertexArrays(1, &renderer->debug_sphere_vao);
        glBindVertexArray(renderer->debug_sphere_vao);
        {
            glGenBuffers(1, &renderer->debug_sphere_vertex_buffer);
            glBindBuffer(GL_ARRAY_BUFFER, renderer->debug_sphere_vertex_buffer);
            glBufferData(GL_ARRAY_BUFFER, sizeof(global_debug_sphere_model_data), global_debug_sphere_model_data,
                         GL_STATIC_DRAW);
            glEnableVertexAttribArray(0);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
            
            glGenBuffers(1, &renderer->debug_sphere_buffer);
            glBindBuffer(GL_ARRAY_BUFFER, renderer->debug_sphere_buffer);
            glBufferData(GL_ARRAY_BUFFER, sizeof(renderer->debug_sphere_instance_data), 0, GL_DYNAMIC_DRAW);
            _SetOpenGLInstancedFloatAttributeData(1, RENDERER_OPENGL_BYTES_PER_DEBUG_SPHERE, 4, 0);
            _SetOpenGLInstancedFloatAttributeData(2, RENDERER_OPENGL_BYTES_PER_DEBUG_SPHERE, 4, 4);
        }
        glBindVertexArray(0);
    }
    
    // NOTE(rjf): Initialize game-specific rendering stuff
    {
        // NOTE(rjf): We can just set the width of the textures to 0,
        //            and let the first frame catch this and force the
        //            size to screen size.
        renderer->active_fbo = 0;
        renderer->main_fbo.w = 0;
        renderer->main_2d_fbo.w = 0;
        renderer->world_fbo.w = 0;
        renderer->screen_size_scratch_fbo.w = 0;
    }
    
    // NOTE(rjf): Load shaders
    {
        for(u32 i = 0; i < OPENGL_SHADER_MAX; ++i)
        {
            renderer->shaders[i] =
                InitOpenGLShaderFromData(global_opengl_shaders[i].inputs, global_opengl_shaders[i].input_count,
                                         global_opengl_shaders[i].outputs, global_opengl_shaders[i].output_count,
                                         global_opengl_shaders[i].vert, global_opengl_shaders[i].frag);
        }
    }
    
    renderer->request_count = 0;
}

internal void
RendererCleanUp(Renderer *renderer)
{}

internal void
RendererBeginFrame(Renderer *renderer, f32 render_w, f32 render_h)
{
    renderer->render_w = render_w;
    renderer->render_h = render_h;
    
    renderer->line_instance_data_alloc_pos = 0;
    renderer->filled_rect_instance_data_alloc_pos = 0;
    renderer->texture_instance_data_alloc_pos = 0;
    renderer->text_instance_data_alloc_pos = 0;
    renderer->debug_sphere_instance_data_alloc_pos = 0;
    
    renderer->active_request.type = 0;
    renderer->request_count = 0;
    renderer->clip_stack_size = 0;
    renderer->current_clip = v4(0, 0, render_w, render_h);
    
    RendererOpenGLFBOForceSize(&renderer->main_fbo, (u32)render_w, (u32)render_h,
                               RENDERER_OPENGL_FBO_COLOR_OUT_0 |
                               RENDERER_OPENGL_FBO_DEPTH_OUT);
    RendererOpenGLFBOForceSize(&renderer->main_2d_fbo, (u32)render_w, (u32)render_h,
                               RENDERER_OPENGL_FBO_COLOR_OUT_0 |
                               RENDERER_OPENGL_FBO_DEPTH_OUT);
    RendererOpenGLFBOForceSize(&renderer->world_fbo, (u32)render_w, (u32)render_h,
                               RENDERER_OPENGL_FBO_COLOR_OUT_0 |
                               RENDERER_OPENGL_FBO_COLOR_OUT_1 |
                               RENDERER_OPENGL_FBO_DEPTH_OUT);
    RendererOpenGLFBOForceSize(&renderer->shadow_map_fbo, 1024, 1024,
                               RENDERER_OPENGL_FBO_DEPTH_OUT);
    RendererOpenGLFBOForceSize(&renderer->screen_size_scratch_fbo, (u32)render_w, (u32)render_h,
                               RENDERER_OPENGL_FBO_COLOR_OUT_0);
    
    renderer->light_count = 0;
}

internal void
RendererEndFrame(Renderer *renderer)
{
    _RendererInternalFinishActiveRequest(renderer);
    
    glDisable(GL_SCISSOR_TEST);
    glClearColor(0, 0, 0, 1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_SCISSOR_TEST);
    glViewport(0, 0, (GLsizei)renderer->render_w, (GLsizei)renderer->render_h);
    glScissor(0, 0, (GLint)renderer->render_w, (GLint)renderer->render_h);
    
    RendererOpenGLFBOClear(renderer, &renderer->world_fbo);
    RendererOpenGLFBOClear(renderer, &renderer->main_fbo);
    RendererOpenGLFBOClear(renderer, &renderer->main_2d_fbo);
    RendererOpenGLFBOClear(renderer, &renderer->shadow_map_fbo);
    
    b32 world_enabled = 0;
    b32 background_enabled = 0;
    v4 active_clip = {
        0, 0, renderer->render_w, renderer->render_h
    };
    
    m4 identity = M4InitD(1.f);
    
    m4 projection_3d = identity;
    m4 projection_2d = M4Orthographic(0, renderer->render_w, renderer->render_h, 0, -100.f, 100.f);
    
    m4 view = identity;
    m4 view_3d = identity;
    m4 projection = projection_2d;
    m4 view_projection = projection;
    view = projection = view_projection = identity;
    m4 inverse_view_projection;
    m4 shadow_view = identity;
    m4 shadow_projection = identity;
    m4 shadow_view_projection = identity;
    
    for(u32 i = 0; i < renderer->request_count; ++i)
    {
        RendererRequest *request = renderer->requests + i;
        
        b32 additive = request->flags & RENDERER_ADDITIVE_BLEND;
        
        if(request->flags & RENDERER_2D)
        {
            view = identity;
            view_projection = projection = projection_2d;
            RendererOpenGLFBOBind(renderer, &renderer->main_2d_fbo);
            glDisable(GL_DEPTH_TEST);
            glDepthMask(GL_FALSE);
        }
        else
        {
            view = view_3d;
            projection = projection_3d;
            RendererOpenGLFBOBind(renderer, &renderer->world_fbo);
            glEnable(GL_DEPTH_TEST);
            glDepthMask((request->flags & RENDERER_NO_DEPTH_WRITE) ? GL_FALSE : GL_TRUE);
        }
        
        switch(request->type)
        {
            
            case RENDERER_REQUEST_view_matrix:
            {
                view_3d = request->view;
                view_projection = M4MultiplyM4(projection_3d, view_3d);
                inverse_view_projection = M4Inverse(view_projection);
                break;
            }
            
            case RENDERER_REQUEST_projection_matrix:
            {
                projection_3d = request->projection;
                view_projection = M4MultiplyM4(projection_3d, view_3d);
                inverse_view_projection = M4Inverse(view_projection);
                break;
            }
            
            case RENDERER_REQUEST_shadow_view_matrix:
            {
                shadow_view = request->view;
                shadow_view_projection = M4MultiplyM4(shadow_projection, shadow_view);
                break;
            }
            
            case RENDERER_REQUEST_shadow_projection_matrix:
            {
                shadow_projection = request->projection;
                shadow_view_projection = M4MultiplyM4(shadow_projection, shadow_view);
                break;
            }
            
            case RENDERER_REQUEST_blur_rectangle:
            {
                v4 clip = request->blur_rect;
                glScissor((GLint)clip.x, (GLint)(renderer->render_h - clip.y - clip.height),
                          (GLint)clip.width, (GLint)clip.height);
                
                RendererOpenGLFBOBind(renderer, &renderer->screen_size_scratch_fbo);
                RendererOpenGLBlurredFBORender(renderer, renderer->main_fbo.color_textures[0],
                                               (f32)renderer->main_fbo.width, (f32)renderer->main_fbo.height,
                                               1, 4.f, 12, clip);
                RendererOpenGLFBOBind(renderer, &renderer->main_fbo);
                
                glBindFramebuffer(GL_READ_FRAMEBUFFER, renderer->screen_size_scratch_fbo.fbo);
                glBindFramebuffer(GL_DRAW_FRAMEBUFFER, renderer->main_fbo.fbo);
                glBlitFramebuffer(0, 0, (int)renderer->render_w, (int)renderer->render_h,
                                  0, 0, (int)renderer->render_w, (int)renderer->render_h,
                                  GL_COLOR_BUFFER_BIT, GL_NEAREST);
                
                RendererOpenGLFBOBind(renderer, &renderer->screen_size_scratch_fbo);
                RendererOpenGLBlurredFBORender(renderer, renderer->main_fbo.color_textures[0],
                                               (f32)renderer->main_fbo.width, (f32)renderer->main_fbo.height,
                                               0, 4.f, 12, clip);
                RendererOpenGLFBOBind(renderer, &renderer->main_fbo);
                
                glBindFramebuffer(GL_READ_FRAMEBUFFER, renderer->screen_size_scratch_fbo.fbo);
                glBindFramebuffer(GL_DRAW_FRAMEBUFFER, renderer->main_fbo.fbo);
                glBlitFramebuffer(0, 0, (int)renderer->render_w, (int)renderer->render_h,
                                  0, 0, (int)renderer->render_w, (int)renderer->render_h,
                                  GL_COLOR_BUFFER_BIT, GL_NEAREST);
                
                glScissor((GLint)active_clip.x, (GLint)(renderer->render_h - active_clip.y - active_clip.height),
                          (GLint)active_clip.width, (GLint)active_clip.height);
                
                break;
            }
            
            case RENDERER_REQUEST_set_clip:
            {
                v4 clip = request->clip;
                glScissor((GLint)clip.x, (GLint)(renderer->render_h - clip.y - clip.height),
                          (GLint)clip.width, (GLint)clip.height);
                active_clip = clip;
                break;
            }
            
            case RENDERER_REQUEST_line:
            {
                // NOTE(rjf): Upload data
                {
                    glBindBuffer(GL_ARRAY_BUFFER, renderer->line_instance_buffer);
                    glBufferSubData(GL_ARRAY_BUFFER, 0, request->data_size,
                                    renderer->line_instance_data + request->data_offset);
                    glBindBuffer(GL_ARRAY_BUFFER, 0);
                }
                
                GLuint shader = renderer->shaders[OPENGL_SHADER_line];
                glUseProgram(shader);
                glBindVertexArray(renderer->line_vao);
                {
                    glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"),
                                       1, GL_FALSE,
                                       &view_projection.elements[0][0]);
                    
                    GLint first = 0;
                    GLsizei count = 2;
                    GLsizei instance_count = request->data_size / RENDERER_OPENGL_BYTES_PER_LINE;
                    
                    glDrawArraysInstanced(GL_LINES, first, count, instance_count);
                }
                glBindVertexArray(0);
                break;
            }
            
            case RENDERER_REQUEST_filled_rect:
            {
                // NOTE(rjf): Upload data
                {
                    glBindBuffer(GL_ARRAY_BUFFER, renderer->filled_rect_instance_buffer);
                    glBufferSubData(GL_ARRAY_BUFFER, 0, request->data_size,
                                    renderer->filled_rect_instance_data + request->data_offset);
                    glBindBuffer(GL_ARRAY_BUFFER, 0);
                }
                
                GLuint shader = renderer->shaders[OPENGL_SHADER_filled_rect];
                glUseProgram(shader);
                glBindVertexArray(renderer->filled_rect_vao);
                {
                    glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"),
                                       1, GL_FALSE,
                                       &view_projection.elements[0][0]);
                    
                    GLint first = 0;
                    GLsizei count = 4;
                    GLsizei instance_count = request->data_size / RENDERER_OPENGL_BYTES_PER_FILLED_RECT;
                    
                    glDrawArraysInstanced(GL_TRIANGLE_STRIP, first, count, instance_count);
                }
                glBindVertexArray(0);
                break;
            }
            
            case RENDERER_REQUEST_texture:
            {
                
                if(additive)
                {
                    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE,
                                        GL_SRC_ALPHA, GL_ONE);
                }
                
                // NOTE(rjf): Upload data
                {
                    glBindBuffer(GL_ARRAY_BUFFER, renderer->texture_instance_buffer);
                    glBufferSubData(GL_ARRAY_BUFFER, 0, request->data_size,
                                    renderer->texture_instance_data + request->data_offset);
                    glBindBuffer(GL_ARRAY_BUFFER, 0);
                }
                
                GLuint shader = 0;
                if(request->flags & RENDERER_2D)
                {
                    shader = renderer->shaders[OPENGL_SHADER_texture];
                }
                else
                {
                    shader = renderer->shaders[OPENGL_SHADER_texture_3d];
                }
                
                glBindVertexArray(renderer->texture_vao);
                glUseProgram(shader);
                {
                    glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"), 1, GL_FALSE,
                                       &view_projection.elements[0][0]);
                    glActiveTexture(GL_TEXTURE0);
                    glBindTexture(GL_TEXTURE_2D, request->texture->id);
                    
                    if(request->flags & RENDERER_2D)
                    {
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                    }
                    else
                    {
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
                        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -1);
                    }
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
                    
                    glUniform1i(glGetUniformLocation(shader, "tex"), 0);
                    glUniform2f(glGetUniformLocation(shader, "tex_resolution"),
                                (f32)request->texture->w,
                                (f32)request->texture->h);
                    
                    GLint first = 0;
                    GLsizei count = 4;
                    GLsizei instance_count = request->data_size / RENDERER_OPENGL_BYTES_PER_TEXTURE;
                    glDrawArraysInstanced(GL_TRIANGLE_STRIP, first, count, instance_count);
                }
                glBindVertexArray(0);
                
                if(additive)
                {
                    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,
                                        GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                }
                
                // NOTE(rjf): Do shadow mapping path if necessary
                if(!(request->flags & RENDERER_2D) &&
                   !(request->flags & RENDERER_NO_SHADOW) &&
                   !(request->flags & RENDERER_NO_DEPTH_WRITE))
                {
                    RendererOpenGLFBO *last_fbo = renderer->active_fbo;
                    RendererOpenGLFBOBind(renderer, &renderer->shadow_map_fbo);
                    
                    shader = renderer->shaders[OPENGL_SHADER_texture_3d_depth];
                    
                    glBindVertexArray(renderer->texture_vao);
                    glUseProgram(shader);
                    {
                        glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"), 1, GL_FALSE,
                                           &shadow_view_projection.elements[0][0]);
                        glActiveTexture(GL_TEXTURE0);
                        glBindTexture(GL_TEXTURE_2D, request->texture->id);
                        
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
                        glUniform1i(glGetUniformLocation(shader, "tex"), 0);
                        glUniform2f(glGetUniformLocation(shader, "tex_resolution"),
                                    (f32)request->texture->w,
                                    (f32)request->texture->h);
                        
                        GLint first = 0;
                        GLsizei count = 4;
                        GLsizei instance_count = request->data_size / RENDERER_OPENGL_BYTES_PER_TEXTURE;
                        glDrawArraysInstanced(GL_TRIANGLE_STRIP, first, count, instance_count);
                    }
                    glBindVertexArray(0);
                    
                    RendererOpenGLFBOBind(renderer, last_fbo);
                }
                
                break;
            }
            
            case RENDERER_REQUEST_text:
            {
                // NOTE(rjf): Upload data
                {
                    glBindBuffer(GL_ARRAY_BUFFER, renderer->text_instance_buffer);
                    glBufferSubData(GL_ARRAY_BUFFER, 0, request->data_size,
                                    renderer->text_instance_data + request->data_offset);
                    glBindBuffer(GL_ARRAY_BUFFER, 0);
                }
                
                GLuint shader = renderer->shaders[OPENGL_SHADER_text];
                glBindVertexArray(renderer->text_vao);
                glUseProgram(shader);
                {
                    
                    glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"),
                                       1, GL_FALSE,
                                       &view_projection.elements[0][0]);
                    
                    glActiveTexture(GL_TEXTURE0);
                    glBindTexture(GL_TEXTURE_2D, request->texture->id);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
                    glUniform1i(glGetUniformLocation(shader, "tex"), 0);
                    glUniform2f(glGetUniformLocation(shader, "tex_resolution"),
                                (f32)request->texture->w,
                                (f32)request->texture->h);
                    
                    GLint first = 0;
                    GLsizei count = 4;
                    GLsizei instance_count = request->data_size / RENDERER_OPENGL_BYTES_PER_TEXT;
                    
                    glDrawArraysInstanced(GL_TRIANGLE_STRIP, first, count, instance_count);
                }
                glBindVertexArray(0);
                break;
            }
            
            case RENDERER_REQUEST_model:
            {
                
                // NOTE(rjf): Do G-buffer path
                {
                    GLuint vao = request->model_vao;
                    GLuint shader = renderer->shaders[OPENGL_SHADER_model];
                    m4 model = request->model_matrix;
                    glBindVertexArray(vao);
                    glUseProgram(shader);
                    {
                        glUniformMatrix4fv(glGetUniformLocation(shader, "model"),
                                           1, GL_FALSE,
                                           &model.elements[0][0]);
                        
                        glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"),
                                           1, GL_FALSE,
                                           &view_projection.elements[0][0]);
                        
                        glActiveTexture(GL_TEXTURE0);
                        glBindTexture(GL_TEXTURE_2D, request->texture->id);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
                        glUniform1i(glGetUniformLocation(shader, "tex"), 0);
                        
                        GLint first = 0;
                        GLsizei count = request->model_vertex_count;
                        glDrawArrays(GL_TRIANGLES, first, count);
                    }
                    glBindVertexArray(0);
                }
                
                // NOTE(rjf): Do shadow-map path
                if(!(request->flags & RENDERER_NO_SHADOW) &&
                   !(request->flags & RENDERER_NO_DEPTH_WRITE))
                {
                    RendererOpenGLFBO *last_fbo = renderer->active_fbo;
                    RendererOpenGLFBOBind(renderer, &renderer->shadow_map_fbo);
                    
                    GLuint vao = request->model_vao;
                    GLuint shader = renderer->shaders[OPENGL_SHADER_model_depth];
                    m4 model = request->model_matrix;
                    glBindVertexArray(vao);
                    glUseProgram(shader);
                    {
                        glUniformMatrix4fv(glGetUniformLocation(shader, "model"),
                                           1, GL_FALSE,
                                           &model.elements[0][0]);
                        
                        glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"),
                                           1, GL_FALSE,
                                           &shadow_view_projection.elements[0][0]);
                        GLint first = 0;
                        GLsizei count = request->model_vertex_count;
                        glDrawArrays(GL_TRIANGLES, first, count);
                    }
                    glBindVertexArray(0);
                    
                    RendererOpenGLFBOBind(renderer, last_fbo);
                }
                
                break;
            }
            
            case RENDERER_REQUEST_debug_sphere:
            {
                // NOTE(rjf): Upload data
                {
                    glBindBuffer(GL_ARRAY_BUFFER, renderer->debug_sphere_buffer);
                    glBufferSubData(GL_ARRAY_BUFFER, 0, request->data_size,
                                    renderer->debug_sphere_instance_data + request->data_offset);
                    glBindBuffer(GL_ARRAY_BUFFER, 0);
                }
                
                glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
                
                GLuint shader = renderer->shaders[OPENGL_SHADER_debug_sphere];
                glUseProgram(shader);
                glBindVertexArray(renderer->debug_sphere_vao);
                {
                    glUniformMatrix4fv(glGetUniformLocation(shader, "view_projection"),
                                       1, GL_FALSE,
                                       &view_projection.elements[0][0]);
                    
                    GLint first = 0;
                    GLsizei count = sizeof(global_debug_sphere_model_data)/(3*sizeof(f32));
                    GLsizei instance_count = request->data_size / RENDERER_OPENGL_BYTES_PER_DEBUG_SPHERE;
                    
                    glDrawArraysInstanced(GL_TRIANGLE_STRIP, first, count, instance_count);
                }
                glBindVertexArray(0);
                
                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
                
                break;
            }
            
            default: break;
        }
    }
    
    glUseProgram(0);
    
    // NOTE(rjf): Render world to main framebuffer
    {
        RendererOpenGLFBOBind(renderer, &renderer->main_fbo);
        glDepthMask(GL_TRUE);
        GLuint shader = renderer->shaders[OPENGL_SHADER_world];
        glUseProgram(shader);
        glBindVertexArray(renderer->all_purpose_vao);
        {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, renderer->world_fbo.color_textures[0]);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, renderer->world_fbo.color_textures[1]);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, renderer->world_fbo.depth_texture);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            
            glActiveTexture(GL_TEXTURE3);
            glBindTexture(GL_TEXTURE_2D, renderer->shadow_map_fbo.depth_texture);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);
            
            glUniformMatrix4fv(glGetUniformLocation(shader, "inverse_view_projection"),
                               1, GL_FALSE,
                               &inverse_view_projection.elements[0][0]);
            
            glUniformMatrix4fv(glGetUniformLocation(shader, "shadow_view_projection"),
                               1, GL_FALSE,
                               &shadow_view_projection.elements[0][0]);
            
            glUniform1i(glGetUniformLocation(shader, "albedo_texture"), 0);
            glUniform1i(glGetUniformLocation(shader, "normal_texture"), 1);
            glUniform1i(glGetUniformLocation(shader, "depth_texture"), 2);
            glUniform1i(glGetUniformLocation(shader, "shadow_map_texture"), 3);
            
            // NOTE(rjf): Upload light information
            {
                local_persist char light_pos_uniform_str_1_digit[32] = "lights[x].position";
                local_persist char light_pos_uniform_str_2_digit[32] = "lights[xx].position";
                local_persist char light_color_uniform_str_1_digit[32] = "lights[x].color";
                local_persist char light_color_uniform_str_2_digit[32] = "lights[xx].color";
                local_persist char light_radius_uniform_str_1_digit[32] = "lights[x].radius";
                local_persist char light_radius_uniform_str_2_digit[32] = "lights[xx].radius";
                local_persist char light_intensity_uniform_str_1_digit[32] = "lights[x].intensity";
                local_persist char light_intensity_uniform_str_2_digit[32] = "lights[xx].intensity";
                
                char *light_pos_uniform_str = 0;
                char *light_color_uniform_str = 0;
                char *light_radius_uniform_str = 0;
                char *light_intensity_uniform_str = 0;
                
                int number_of_lights_that_were_sent_to_shader = 0;
                
                for(u32 i = 0; i < renderer->light_count && i < 16; ++i)
                {
                    
                    if(number_of_lights_that_were_sent_to_shader < 10)
                    {
                        light_pos_uniform_str = light_pos_uniform_str_1_digit;
                        light_color_uniform_str = light_color_uniform_str_1_digit;
                        light_radius_uniform_str = light_radius_uniform_str_1_digit;
                        light_intensity_uniform_str = light_intensity_uniform_str_1_digit;
                        
                        light_pos_uniform_str[7] = '0' + (i32)number_of_lights_that_were_sent_to_shader;
                        light_color_uniform_str[7] = '0' + (i32)number_of_lights_that_were_sent_to_shader;
                        light_radius_uniform_str[7] = '0' + (i32)number_of_lights_that_were_sent_to_shader;
                        light_intensity_uniform_str[7] = '0' + (i32)number_of_lights_that_were_sent_to_shader;
                    }
                    else if(number_of_lights_that_were_sent_to_shader < 20)
                    {
                        light_pos_uniform_str = light_pos_uniform_str_2_digit;
                        light_color_uniform_str = light_color_uniform_str_2_digit;
                        light_radius_uniform_str = light_radius_uniform_str_2_digit;
                        light_intensity_uniform_str = light_intensity_uniform_str_2_digit;
                        
                        light_pos_uniform_str[7] = '1';
                        light_color_uniform_str[7] = '1';
                        light_radius_uniform_str[7] = '1';
                        light_intensity_uniform_str[7] = '1';
                        
                        light_pos_uniform_str[8] = '0' + ((i32)number_of_lights_that_were_sent_to_shader - 10);
                        light_color_uniform_str[8] = '0' + ((i32)number_of_lights_that_were_sent_to_shader - 10);
                        light_radius_uniform_str[8] = '0' + ((i32)number_of_lights_that_were_sent_to_shader - 10);
                        light_intensity_uniform_str[8] = '0' + ((i32)number_of_lights_that_were_sent_to_shader - 10);
                    }
                    else
                    {
                        HardAssert("NOTE(rjf): We did not plan for this many lights to be sent to to the shader" == 0);
                    }
                    
                    glUniform3f(glGetUniformLocation(shader, light_pos_uniform_str),
                                renderer->lights[i].position.x,
                                renderer->lights[i].position.y,
                                renderer->lights[i].position.z);
                    glUniform3f(glGetUniformLocation(shader, light_color_uniform_str),
                                renderer->lights[i].color.r,
                                renderer->lights[i].color.g,
                                renderer->lights[i].color.b);
                    glUniform1f(glGetUniformLocation(shader, light_radius_uniform_str),
                                renderer->lights[i].radius);
                    glUniform1f(glGetUniformLocation(shader, light_intensity_uniform_str),
                                renderer->lights[i].intensity);
                    
                    ++number_of_lights_that_were_sent_to_shader;
                }
                
                glUniform1i(glGetUniformLocation(shader, "light_count"),
                            number_of_lights_that_were_sent_to_shader);
            }
            
            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        }
        glBindVertexArray(0);
    }
    
    // NOTE(rjf): Do FXAA pass on main framebuffer to default framebuffer
    {
        RendererOpenGLFBOBind(renderer, 0);
        glDepthMask(GL_TRUE);
        GLuint shader = renderer->shaders[OPENGL_SHADER_fxaa];
        glUseProgram(shader);
        glBindVertexArray(renderer->all_purpose_vao);
        {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, renderer->main_fbo.color_textures[0]);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            glUniform1i(glGetUniformLocation(shader, "color_tex"), 0);
            glUniform2f(glGetUniformLocation(shader, "color_tex_resolution"),
                        renderer->render_w, renderer->render_h);
            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        }
        glBindVertexArray(0);
    }
    
    // NOTE(rjf): Do FXAA pass on main 2D framebuffer to default framebuffer
    {
        RendererOpenGLFBOBind(renderer, 0);
        glDepthMask(GL_TRUE);
        GLuint shader = renderer->shaders[OPENGL_SHADER_fxaa];
        glUseProgram(shader);
        glBindVertexArray(renderer->all_purpose_vao);
        {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, renderer->main_2d_fbo.color_textures[0]);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            glUniform1i(glGetUniformLocation(shader, "color_tex"), 0);
            glUniform2f(glGetUniformLocation(shader, "color_tex_resolution"),
                        renderer->render_w, renderer->render_h);
            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        }
        glBindVertexArray(0);
    }
    
    GLenum error = glGetError();
    if(error)
    {
        Log("[OpenGL Error] %i", (int)error);
    }
}

internal void
RendererPushClip(Renderer *renderer, v4 clip)
{
    _RendererInternalFinishActiveRequest(renderer);
    
    HardAssert(renderer->clip_stack_size < RENDERER_CLIP_STACK_MAX);
    renderer->clip_stack[renderer->clip_stack_size++] = renderer->current_clip;
    renderer->current_clip = clip;
    
    AssertStatement(renderer->request_count < RENDERER_MAX_REQUESTS);
    u64 i = renderer->request_count++;
    RendererRequest request = {
        RENDERER_REQUEST_set_clip,
    };
    request.clip = renderer->current_clip;
    renderer->requests[i] = request;
}

internal void
RendererPushClipThatIsConstrainedByCurrent(Renderer *renderer, v4 clip)
{
    v4 parent_clip = renderer->current_clip;
    v4 new_clip = v4(MaximumF32(clip.x, parent_clip.x),
                     MaximumF32(clip.y, parent_clip.y),
                     clip.width, clip.height);
    
    if(clip.x + clip.width > parent_clip.x + parent_clip.width)
    {
        new_clip.width = parent_clip.width;
    }
    
    if(clip.y + clip.height > parent_clip.y + parent_clip.height)
    {
        new_clip.height = parent_clip.height;
    }
    
    RendererPushClip(renderer, new_clip);
}

internal void
RendererPopClip(Renderer *renderer)
{
    _RendererInternalFinishActiveRequest(renderer);
    
    SoftAssert(renderer->clip_stack_size > 0);
    if(renderer->clip_stack_size > 0)
    {
        renderer->current_clip = renderer->clip_stack[--renderer->clip_stack_size];
    }
    
    AssertStatement(renderer->request_count < RENDERER_MAX_REQUESTS);
    u64 i = renderer->request_count++;
    RendererRequest request = {
        RENDERER_REQUEST_set_clip,
    };
    request.clip = renderer->current_clip;
    renderer->requests[i] = request;
}

internal void
RendererPushRectangleBlur(Renderer *renderer, v4 rect, f32 blur_magnitude)
{
    _RendererInternalFinishActiveRequest(renderer);
    
    AssertStatement(renderer->request_count < RENDERER_MAX_REQUESTS);
    u64 i = renderer->request_count++;
    RendererRequest request = {
        RENDERER_REQUEST_blur_rectangle,
    };
    request.blur_rect = rect;
    request.blur_magnitude = blur_magnitude;
    renderer->requests[i] = request;
}

internal void
_RendererPushLine(Renderer *renderer, i32 flags, v4 color, v3 p1, v3 p2)
{
    Assert(renderer->line_instance_data_alloc_pos + RENDERER_OPENGL_BYTES_PER_LINE <= sizeof(renderer->line_instance_data));
    RendererRequestType request_type = RENDERER_REQUEST_line;
    if(renderer->active_request.type != request_type ||
       renderer->active_request.flags != flags)
    {
        _RendererInternalFinishActiveRequest(renderer);
        renderer->active_request.type = request_type;
        renderer->active_request.data_offset = renderer->line_instance_data_alloc_pos;
        renderer->active_request.data_size = RENDERER_OPENGL_BYTES_PER_LINE;
        renderer->active_request.flags = flags;
    }
    else
    {
        renderer->active_request.data_size += RENDERER_OPENGL_BYTES_PER_LINE;
    }
    
    GLubyte *data = (renderer->line_instance_data + renderer->line_instance_data_alloc_pos);
    ((f32 *)data)[0] = p1.x;
    ((f32 *)data)[1] = p1.y;
    ((f32 *)data)[2] = p1.z;
    ((f32 *)data)[3] = p2.x;
    ((f32 *)data)[4] = p2.y;
    ((f32 *)data)[5] = p2.z;
    ((f32 *)data)[6] = color.r;
    ((f32 *)data)[7] = color.g;
    ((f32 *)data)[8] = color.b;
    ((f32 *)data)[9] = color.a;
    renderer->line_instance_data_alloc_pos += RENDERER_OPENGL_BYTES_PER_LINE;
}

internal void
RendererPushLine(Renderer *renderer, v4 color, v3 p1, v3 p2)
{
    _RendererPushLine(renderer, 0, color, p1, p2);
}

internal void
RendererPushLineF(Renderer *renderer, i32 flags, v4 color, v3 p1, v3 p2)
{
    _RendererPushLine(renderer, flags, color, p1, p2);
}

internal void
RendererPushLine2D(Renderer *renderer, v4 color, v2 p1, v2 p2)
{
    v3 p1_3d = { p1.x, p1.y, 0 };
    v3 p2_3d = { p2.x, p2.y, 0 };
    _RendererPushLine(renderer, RENDERER_2D, color, p1_3d, p2_3d);
}

internal void
RendererPushRect2D(Renderer *renderer, v4 color, v4 rect)
{
    v2 p1 = { rect.x, rect.y };
    v2 p2 = { rect.x, rect.y + rect.height };
    v2 p3 = { rect.x + rect.width, rect.y + rect.height };
    v2 p4 = { rect.x + rect.width, rect.y };
    RendererPushLine2D(renderer, color, p1, p2);
    RendererPushLine2D(renderer, color, p2, p3);
    RendererPushLine2D(renderer, color, p3, p4);
    RendererPushLine2D(renderer, color, p4, p1);
}

internal void
_RendererPushFilledRect(Renderer *renderer, i32 flags,
                        v4 color00, v4 color01, v4 color10, v4 color11,
                        v3 p1, v3 p2, v3 p3, v3 p4)
{
    
    Assert(renderer->filled_rect_instance_data_alloc_pos + RENDERER_OPENGL_BYTES_PER_FILLED_RECT <= sizeof(renderer->filled_rect_instance_data));
    RendererRequestType request_type = RENDERER_REQUEST_filled_rect;
    if(renderer->active_request.type != request_type || flags != renderer->active_request.flags)
    {
        _RendererInternalFinishActiveRequest(renderer);
        renderer->active_request.type = request_type;
        renderer->active_request.data_offset = renderer->filled_rect_instance_data_alloc_pos;
        renderer->active_request.data_size = RENDERER_OPENGL_BYTES_PER_FILLED_RECT;
        renderer->active_request.flags = flags;
    }
    else
    {
        renderer->active_request.data_size += RENDERER_OPENGL_BYTES_PER_FILLED_RECT;
    }
    
    GLubyte *data = (renderer->filled_rect_instance_data +
                     renderer->filled_rect_instance_data_alloc_pos);
    ((f32 *)data)[0]  = p1.x;
    ((f32 *)data)[1]  = p1.y;
    ((f32 *)data)[2]  = p1.z;
    ((f32 *)data)[3]  = p2.x;
    ((f32 *)data)[4]  = p2.y;
    ((f32 *)data)[5]  = p2.z;
    ((f32 *)data)[6]  = p3.x;
    ((f32 *)data)[7]  = p3.y;
    ((f32 *)data)[8]  = p3.z;
    ((f32 *)data)[9]  = p4.x;
    ((f32 *)data)[10] = p4.y;
    ((f32 *)data)[11] = p4.z;
    ((f32 *)data)[12] = color00.x;
    ((f32 *)data)[13] = color00.y;
    ((f32 *)data)[14] = color00.z;
    ((f32 *)data)[15] = color00.w;
    ((f32 *)data)[16] = color01.x;
    ((f32 *)data)[17] = color01.y;
    ((f32 *)data)[18] = color01.z;
    ((f32 *)data)[19] = color01.w;
    ((f32 *)data)[20] = color10.x;
    ((f32 *)data)[21] = color10.y;
    ((f32 *)data)[22] = color10.z;
    ((f32 *)data)[23] = color10.w;
    ((f32 *)data)[24] = color11.x;
    ((f32 *)data)[25] = color11.y;
    ((f32 *)data)[26] = color11.z;
    ((f32 *)data)[27] = color11.w;
    renderer->filled_rect_instance_data_alloc_pos += RENDERER_OPENGL_BYTES_PER_FILLED_RECT;
}

internal void
RendererPushFilledRect2DV(Renderer *renderer, v4 color00, v4 color01, v4 color10, v4 color11, v4 rect)
{
    v3 p1 = { rect.x, rect.y, 0 };
    v3 p2 = { rect.x, rect.y + rect.height, 0 };
    v3 p3 = { rect.x + rect.width, rect.y, 0 };
    v3 p4 = { rect.x + rect.width, rect.y + rect.height, 0 };
    _RendererPushFilledRect(renderer, RENDERER_2D,
                            color00, color01, color10, color11,
                            p1, p2, p3, p4);
}

internal void
RendererPushFilledRect2D(Renderer *renderer, v4 color, v4 rect)
{
    RendererPushFilledRect2DV(renderer, color, color, color, color, rect);
}

internal void
RendererPushFilledRect(Renderer *renderer, v4 color, v3 p1, v3 p2, v3 p3, v3 p4)
{
    _RendererPushFilledRect(renderer, 0, color, color, color, color, p1, p2, p3, p4);
}

internal void
_RendererPushTexture(Renderer *renderer, Texture *texture, i32 flags,
                     v4 source, v3 p1, v3 p2, v3 p3, v3 p4, v4 tint)
{
    Assert(renderer->texture_instance_data_alloc_pos + RENDERER_OPENGL_BYTES_PER_TEXTURE <= sizeof(renderer->texture_instance_data));
    RendererRequestType request_type = RENDERER_REQUEST_texture;
    
    if(renderer->active_request.type != request_type ||
       renderer->active_request.texture != texture ||
       renderer->active_request.flags != flags)
    {
        _RendererInternalFinishActiveRequest(renderer);
        renderer->active_request.type = request_type;
        renderer->active_request.data_offset = renderer->texture_instance_data_alloc_pos;
        renderer->active_request.data_size = RENDERER_OPENGL_BYTES_PER_TEXTURE;
        renderer->active_request.texture = texture;
        renderer->active_request.flags = flags;
    }
    else
    {
        renderer->active_request.data_size += RENDERER_OPENGL_BYTES_PER_TEXTURE;
    }
    
    if(flags & RENDERER_FLIP_HORIZONTAL)
    {
        source.x += source.width;
        source.width *= -1;
    }
    
    if(flags & RENDERER_FLIP_VERTICAL)
    {
        source.y += source.height;
        source.height *= -1;
    }
    
    GLubyte *data = (renderer->texture_instance_data +
                     renderer->texture_instance_data_alloc_pos);
    ((f32 *)data)[0]  = source.x;
    ((f32 *)data)[1]  = source.y;
    ((f32 *)data)[2]  = source.width;
    ((f32 *)data)[3]  = source.height;
    ((f32 *)data)[4]  = p1.x;
    ((f32 *)data)[5]  = p1.y;
    ((f32 *)data)[6]  = p1.z;
    ((f32 *)data)[7]  = p2.x;
    ((f32 *)data)[8]  = p2.y;
    ((f32 *)data)[9]  = p2.z;
    ((f32 *)data)[10] = p3.x;
    ((f32 *)data)[11] = p3.y;
    ((f32 *)data)[12] = p3.z;
    ((f32 *)data)[13] = p4.x;
    ((f32 *)data)[14] = p4.y;
    ((f32 *)data)[15] = p4.z;
    ((f32 *)data)[16] = tint.r;
    ((f32 *)data)[17] = tint.g;
    ((f32 *)data)[18] = tint.b;
    ((f32 *)data)[19] = tint.a;
    renderer->texture_instance_data_alloc_pos += RENDERER_OPENGL_BYTES_PER_TEXTURE;
}

internal void
RendererPushTexture2DF(Renderer *renderer, Texture *texture, i32 flags,
                       v4 source, v4 dest, v4 tint)
{
    v3 p1 = { dest.x, dest.y };
    v3 p2 = { dest.x, dest.y + dest.height };
    v3 p3 = { dest.x + dest.width, dest.y };
    v3 p4 = { dest.x + dest.width, dest.y + dest.height };
    
    _RendererPushTexture(renderer, texture, flags | RENDERER_2D,
                         source, p1, p2, p3, p4, tint);
}

internal void
RendererPushTexture2D(Renderer *renderer, Texture *texture, v4 source, v4 dest, v4 tint)
{
    RendererPushTexture2DF(renderer, texture, 0, source, dest, tint);
}

internal void
RendererPushTexture(Renderer *renderer, Texture *texture, i32 flags,
                    v4 source, v3 p1, v3 p2, v3 p3, v3 p4, v4 tint)
{
    source.y += source.height;
    source.height *= -1;
    _RendererPushTexture(renderer, texture, flags, source, p1, p2, p3, p4, tint);
}

internal void
RendererPushTextCharacter(Renderer *renderer, Font *font, i32 flags,
                          v4 color, v3 p1, v3 p2, v3 p3, v3 p4,
                          f32 boldness, f32 softness, int character)
{
    if(character >= 32 && character < 128)
    {
        Texture *texture = &font->texture;
        
        Assert(renderer->text_instance_data_alloc_pos + RENDERER_OPENGL_BYTES_PER_TEXT <= sizeof(renderer->text_instance_data));
        RendererRequestType request_type = RENDERER_REQUEST_text;
        
        if(renderer->active_request.type != request_type ||
           renderer->active_request.texture != texture ||
           renderer->active_request.flags != flags)
        {
            _RendererInternalFinishActiveRequest(renderer);
            renderer->active_request.type = request_type;
            renderer->active_request.data_offset = renderer->text_instance_data_alloc_pos;
            renderer->active_request.data_size = RENDERER_OPENGL_BYTES_PER_TEXT;
            renderer->active_request.texture = texture;
            renderer->active_request.flags = flags;
        }
        else
        {
            renderer->active_request.data_size += RENDERER_OPENGL_BYTES_PER_TEXT;
        }
        
        v4 source = {
            font->char_x[character - 32],
            font->char_y[character - 32],
            font->char_w[character - 32],
            font->char_h[character - 32],
        };
        
        GLubyte *data = (renderer->text_instance_data +
                         renderer->text_instance_data_alloc_pos);
        ((f32 *)data)[0]  = source.x;
        ((f32 *)data)[1]  = source.y;
        ((f32 *)data)[2]  = source.width;
        ((f32 *)data)[3]  = source.height;
        ((f32 *)data)[4]  = p1.x;
        ((f32 *)data)[5]  = p1.y;
        ((f32 *)data)[6]  = p1.z;
        ((f32 *)data)[7]  = p2.x;
        ((f32 *)data)[8]  = p2.y;
        ((f32 *)data)[9]  = p2.z;
        ((f32 *)data)[10] = p3.x;
        ((f32 *)data)[11] = p3.y;
        ((f32 *)data)[12] = p3.z;
        ((f32 *)data)[13] = p4.x;
        ((f32 *)data)[14] = p4.y;
        ((f32 *)data)[15] = p4.z;
        ((f32 *)data)[16] = color.r;
        ((f32 *)data)[17] = color.g;
        ((f32 *)data)[18] = color.b;
        ((f32 *)data)[19] = color.a;
        ((f32 *)data)[20] = boldness;
        ((f32 *)data)[21] = softness;
        renderer->text_instance_data_alloc_pos += RENDERER_OPENGL_BYTES_PER_TEXT;
    }
}

internal f32
RendererPushText(Renderer *renderer, Font *font, i32 flags, v4 color, v3 position,
                 f32 scale, f32 boldness, f32 softness, char *text)
{
    f32 width = 0.f;
    
    if(flags & RENDERER_TEXT_ALIGN_CENTER_X)
    {
        f32 text_width = FontGetTextWidth(font, text) * scale;
        if(flags & RENDERER_2D)
        {
        }
        else
        {
            text_width /= 50.f;
        }
        position.x -= text_width/2.f;
    }
    
    if(font && FontIsLoaded(font))
    {
        for(u32 i = 0; text[i]; ++i)
        {
            char character = text[i];
            
            if(character >= 32 && character < 128)
            {
                v4 source = {
                    font->char_x[character - 32],
                    font->char_y[character - 32],
                    font->char_w[character - 32],
                    font->char_h[character - 32],
                };
                
                if(flags & RENDERER_2D)
                {
                    // source.y += source.height;
                    // source.height *= -1;
                }
                
                v2 size = {
                    scale * source.width,
                    scale * source.height,
                };
                
                v2 offset = {
                    font->char_x_offset[character - 32] * scale,
                    font->char_y_offset[character - 32] * scale,
                };
                
                f32 advance = scale * font->char_x_advance[character - 32];
                
                if(flags & RENDERER_2D)
                {
                    // size.x /= 50.f;
                    // size.y /= 50.f;
                    // advance /= 50.f;
                }
                else
                {
                    size.x /= 50.f;
                    size.y /= 50.f;
                    advance /= 50.f;
                }
                
                v3 p1 = { position.x+0.f*size.x+offset.x, position.y+1.f*size.y+offset.y, position.z+0.f, };
                v3 p2 = { position.x+0.f*size.x+offset.x, position.y+0.f*size.y+offset.y, position.z+0.f, };
                v3 p3 = { position.x+1.f*size.x+offset.x, position.y+1.f*size.y+offset.y, position.z+0.f, };
                v3 p4 = { position.x+1.f*size.x+offset.x, position.y+0.f*size.y+offset.y, position.z+0.f, };
                
                if(flags & RENDERER_2D)
                {
                    p1.y -= 1.f*size.y;
                    p2.y += 1.f*size.y;
                    p3.y -= 1.f*size.y;
                    p4.y += 1.f*size.y;
                    p1.y -= 20.f;
                    p2.y -= 20.f;
                    p3.y -= 20.f;
                    p4.y -= 20.f;
                }
                
                
                RendererPushTextCharacter(renderer, font, flags, color, p1, p2, p3, p4,
                                          boldness, softness, character);
                
                position.x += advance;
                width += advance;
            }
        }
    }
    
    return width;
}

internal f32
RendererPushText2DWithBoldnessAndSoftness(Renderer *renderer, Font *font, i32 flags, v4 color, v2 position,
                                          f32 font_scale, f32 boldness, f32 softness, char *text)
{
    v3 position_xyz = { position.x, position.y, 0 };
    
    return RendererPushText(renderer, font, flags | RENDERER_2D,
                            color, position_xyz, font_scale, boldness, softness, text);
}

internal f32
RendererPushText2D(Renderer *renderer, Font *font, i32 flags, v4 color, v2 position,
                   f32 font_scale, char *text)
{
    
    f32 boldness = 0.62f + (0.12f * (1.f - font_scale));
    f32 softness = 0.10f + (0.22f * (1.f - font_scale));
    
    return RendererPushText2DWithBoldnessAndSoftness(renderer, font, flags,
                                                     color, position, font_scale, boldness, softness, text);
}

internal void
RendererPushViewMatrix(Renderer *renderer, m4 view)
{
    _RendererInternalFinishActiveRequest(renderer);
    RendererRequestType request_type = RENDERER_REQUEST_view_matrix;
    renderer->active_request.type = request_type;
    renderer->active_request.view = view;
    renderer->active_request.flags = 0;
}

internal void
RendererPushProjectionMatrix(Renderer *renderer, m4 projection)
{
    _RendererInternalFinishActiveRequest(renderer);
    RendererRequestType request_type = RENDERER_REQUEST_projection_matrix;
    renderer->active_request.type = request_type;
    renderer->active_request.projection = projection;
    renderer->active_request.flags = 0;
}

internal void
RendererPushShadowViewMatrix(Renderer *renderer, m4 view)
{
    _RendererInternalFinishActiveRequest(renderer);
    RendererRequestType request_type = RENDERER_REQUEST_shadow_view_matrix;
    renderer->active_request.type = request_type;
    renderer->active_request.view = view;
    renderer->active_request.flags = 0;
}

internal void
RendererPushShadowProjectionMatrix(Renderer *renderer, m4 projection)
{
    _RendererInternalFinishActiveRequest(renderer);
    RendererRequestType request_type = RENDERER_REQUEST_shadow_projection_matrix;
    renderer->active_request.type = request_type;
    renderer->active_request.projection = projection;
    renderer->active_request.flags = 0;
}

internal void
RendererPushModel(Renderer *renderer, m4 model_matrix, Model *model, Texture *albedo)
{
    _RendererInternalFinishActiveRequest(renderer);
    RendererRequestType request_type = RENDERER_REQUEST_model;
    renderer->active_request.type = request_type;
    renderer->active_request.model_matrix = model_matrix;
    renderer->active_request.model_vao = model->vao;
    renderer->active_request.texture = albedo;
    renderer->active_request.model_vertex_count = model->vertex_count;
    renderer->active_request.flags = 0;
}

internal void
RendererPushPointLight(Renderer *renderer, v3 position, v3 color, f32 radius, f32 intensity)
{
    HardAssert(renderer->light_count < RENDERER_MAX_LIGHT_COUNT);
    u32 i = renderer->light_count++;
    renderer->lights[i].position = position;
    renderer->lights[i].color = color;
    renderer->lights[i].radius = radius;
    renderer->lights[i].intensity = intensity;
}

internal void
RendererPushDebugSphere(Renderer *renderer, v4 color, v3 position, f32 radius)
{
    
    Assert(renderer->debug_sphere_instance_data_alloc_pos + RENDERER_OPENGL_BYTES_PER_DEBUG_SPHERE <= sizeof(renderer->debug_sphere_instance_data));
    RendererRequestType request_type = RENDERER_REQUEST_debug_sphere;
    i32 flags = 0;
    if(renderer->active_request.type != request_type || flags != renderer->active_request.flags)
    {
        _RendererInternalFinishActiveRequest(renderer);
        renderer->active_request.type = request_type;
        renderer->active_request.data_offset = renderer->debug_sphere_instance_data_alloc_pos;
        renderer->active_request.data_size = RENDERER_OPENGL_BYTES_PER_DEBUG_SPHERE;
        renderer->active_request.flags = flags;
    }
    else
    {
        renderer->active_request.data_size += RENDERER_OPENGL_BYTES_PER_DEBUG_SPHERE;
    }
    
    GLubyte *data = (renderer->debug_sphere_instance_data +
                     renderer->debug_sphere_instance_data_alloc_pos);
    ((f32 *)data)[0]  = color.r;
    ((f32 *)data)[1]  = color.g;
    ((f32 *)data)[2]  = color.b;
    ((f32 *)data)[3]  = color.a;
    ((f32 *)data)[4]  = position.x;
    ((f32 *)data)[5]  = position.y;
    ((f32 *)data)[6]  = position.z;
    ((f32 *)data)[7]  = radius;
    renderer->debug_sphere_instance_data_alloc_pos += RENDERER_OPENGL_BYTES_PER_DEBUG_SPHERE;
}
